# 多线程常见问题

#### 同步（Synchronous）与异步（Asynchronous）

同步和异步一般用于形容方法调用。对于调用者来说，同步方法必须等到方法返回后才能继续后续的行为，而异步则在方法调用后立即返回，调用者可以去干别的事情。

#### 并发（Concurrency）和并行（Parallelism）

**并发**指的不一定是任务的真正同时运行，而是一会儿执行 A，一会儿执行 B，**不断在多个任务之间进行切换**。但是对于观察者来说像是在同时运行。

**并行**指的是任务真的在同时进行，一般在多核 CPU 中发生。

#### 阻塞（Blocking）与非阻塞（Non-Blocking）

阻塞与非阻塞一般用于形容多线程之间的相互影响。阻塞调用是指调用结果返回之前，当前线程会被挂起，一直处于等待消息通知，不能够执行其他业务。而非阻塞指的是没有一个线程可以妨碍其他线程的工作。

#### 死锁与活锁

**死锁**：多个线程占有了其每个线程都需要的资源，你不让我我不让你，造成程序无法继续执行下去。

**活锁**：每个线程都主动地将资源释放给别人用，那么就没有任何一个线程能够顺利占有这个资源执行。

#### 并发的级别

下面的并发级别依次从低到高：

**阻塞（Blocking）**

一个线程是阻塞的，其他线程释放资源前，当前线程无法操作。这是最低级别的并发，例如使用 synchronized 关键字。这里其实就是**悲观锁**的策略。

**无饥饿（Starvation-Free）**

如果**锁是公平的**，不管新来的线程优先级有多高，想要获得资源，也必须**排队等待**前面有可能优先级比较低的先使用资源，这样所有的线程都有机会执行。

**无障碍（Obstruction-Free）** 

多个进程可以一起进入临界区获取资源。为了避免在资源被多个线程修改导致一致性问题发生，其每个线程会在修改资源后进行回滚操作确保数据安全。但是依然会有一个问题就是资源修改的冲突特别大的时候，会导致每个线程一直在回滚，没有一个线程能够走出临界区。这里其实就是**乐观锁**的策略。

**无锁（Lock-Free）**

无锁的并行都是无障碍的，但不同的是无锁的并发保证了必然有一个线程能够在有限步骤内离开临界区。一般通过 CAS 来实现。

**无等待（Wait-Free）**

无等待是要求所有的无障碍线程必须全部在有限步骤内离开临界区，这样就不会遇到饥饿问题。例如 **RCU** 的思想，**读线程不用等待**，**写线程先对元数据进行拷贝副本，再修改副本**，最后找机会**把指向原来数据的指针重新指向新的被修改的数据**。这是**最高的并发级别**，没有任何阻塞。

