# 反射

## 为什么要反射

在实际开发过程中，我们希望通过配置（如一个配置文件）来加载不同的类，调用不同的方法，那么这个时候就需要反射来帮助我们完成这一目标。

## 什么是反射

反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。

通常认为 Java 是静态的强类型语言，但因为提供了反射等机制，才具有了部分动态类型语言的能力。

## 能做什么

- 在运行时能判断任意一个对象所属的类。
- 在运行时能构造任意一个类的对象。
- 在运行时获取、调用任意一个类的成员变量、方法。

## 常用API

### 获取Class对象

1. 使用 Class.forName 静态方法。当你知道该类的全路径名时，你可以使用该方法获取 Class 类对象。

   ```Class clz = Class.forName("java.lang.String");```

2. 使用 .class 方法。

   ```Class clz = String.class;```

3. 使用类对象的 getClass() 方法。

   ```Class clz = "".getClass();```

### 创建类对象

1. 通过 Class 对象的 newInstance() 方法

   ```java
   Class clz = Apple.class;
   Apple apple = (Apple)clz.newInstance();
   ```

2. 通过 Constructor 对象的 newInstance() 方法

   ```java
   Class clz = Apple.class;
   Constructor constructor = clz.getConstructor();
   Apple apple = (Apple)constructor.newInstance();
   ```

## 反射调用实现原理

核心方法是 ```Method.invoke(Object obj, Object... args)```。

```java
public final class Method extends Executable {
  ...
  public Object invoke(Object obj, Object... args) throws ... {
    ... // 权限检查
    MethodAccessor ma = methodAccessor;
    if (ma == null) {
      ma = acquireMethodAccessor();
    }
    return ma.invoke(obj, args);
  }
}
```

这里的 MethodAccessor 是一个接口，有两个具体的实现类：DelegatingMethodAccessorImpl 和 NativeMethodAccessorImpl。执行反射调用的有两种方式：一是 NativeMethodAccessorImpl 所实现的本地（用 C++ 实现）调用，另外就是**动态生成字节码的方式**（下称“动态实现”）实现。

由于动态实现无需经过 Java 到 C++ 再到 Java 的切换，其运行效率是本地调用的20倍，然而生成字节码本身比较耗时，如果仅仅使用一次的话，反而本地调用的效率是它的 3 到 4 倍。因此 Java 实际实现的方式是采用委派（即DelegatingMethodAccessorImpl）的方式，如果反射调用的次数在一个阈值（默认15，可以通过-Dsun.reflect.inflationThreshold=来调整）之下时，采用本地调用，否则便开始动态生成字节码，并将委派实现的对象切换至动态实现，这个过程称为这个过程我们称之为 **Inflation**。

关键代码参考（sun.reflect 下的源码在 Oracle JDK 中并未提供，实际可参考[openjdk](http://hg.openjdk.java.net/jdk8u/jdk8u60/jdk/file/935758609767/src/share/classes/sun/reflect)的实现，基本是一致的）——

1. ```java.lang.reflect.Method```

   ```java
   public Object invoke(Object obj, Object... args)
       throws IllegalAccessException, IllegalArgumentException,
          InvocationTargetException
   {
       if (!override) {
           if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {
               Class<?> caller = Reflection.getCallerClass();
               checkAccess(caller, clazz, obj, modifiers);
           }
       }
       MethodAccessor ma = methodAccessor;             // read volatile
       if (ma == null) {
           ma = acquireMethodAccessor();
       }
       return ma.invoke(obj, args);
   }
   
   private MethodAccessor acquireMethodAccessor() {
       // First check to see if one has been created yet, and take it
       // if so
       MethodAccessor tmp = null;
       if (root != null) tmp = root.getMethodAccessor();
       if (tmp != null) {
           methodAccessor = tmp;
       } else {
           // Otherwise fabricate one and propagate it up to the root
           tmp = reflectionFactory.newMethodAccessor(this);
           setMethodAccessor(tmp);
       }
   
       return tmp;
   }
   ```

2. [```sun.reflect.ReflectionFactory```](http://hg.openjdk.java.net/jdk8u/jdk8u60/jdk/file/935758609767/src/share/classes/sun/reflect/ReflectionFactory.java)

    ```java
    private static boolean noInflation        = false;
    private static int     inflationThreshold = 15;
    
    public MethodAccessor newMethodAccessor(Method method) {
        checkInitted();
    
        if (noInflation && !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) {
            // 如果不采用 inflation 方式，则使用动态实现的方式
            // 可以通过 -Dsun.reflect.noInflation=true 来指定
            return new MethodAccessorGenerator().
                generateMethod(method.getDeclaringClass(),
                               method.getName(),
                               method.getParameterTypes(),
                               method.getReturnType(),
                               method.getExceptionTypes(),
                               method.getModifiers());
        } else {
            // 默认采用 inflation 方式
            NativeMethodAccessorImpl acc =
                new NativeMethodAccessorImpl(method);
            DelegatingMethodAccessorImpl res =
                new DelegatingMethodAccessorImpl(acc); // 将委派对象设置为本地调用
            acc.setParent(res);
            return res;
        }
    }
    ```

2. [```sun.reflect.NativeMethodAccessorImpl```](http://hg.openjdk.java.net/jdk8u/jdk8u60/jdk/file/935758609767/src/share/classes/sun/reflect/NativeMethodAccessorImpl.java)

   ```java
   public Object invoke(Object obj, Object[] args)
           throws IllegalArgumentException, InvocationTargetException
   {
       // We can't inflate methods belonging to vm-anonymous classes because
       // that kind of class can't be referred to by name, hence can't be
       // found from the generated bytecode.
       // 如果超过了15次且非匿名内部类，则采用动态实现的方式
       // 因为匿名内部类无法通过名称指定，因而无法通过动态字节码来生成
       if (++numInvocations > ReflectionFactory.inflationThreshold()
               && !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) {
           // 生成一个动态实现的对象
           // 感兴趣的可以继续阅读MethodAccessorGenerator源码，其中采用了 asm 操作字节码的技术
           MethodAccessorImpl acc = (MethodAccessorImpl)
               new MethodAccessorGenerator().
                   generateMethod(method.getDeclaringClass(),
                                  method.getName(),
                                  method.getParameterTypes(),
                                  method.getReturnType(),
                                  method.getExceptionTypes(),
                                  method.getModifiers());
                                  
           // 将委派对象设置为动态实现
           parent.setDelegate(acc);
       }
   	
   	// 否则采用本地实现
       return invoke0(method, obj, args);
   }
   
   // 本地实现
   private static native Object invoke0(Method m, Object obj, Object[] args);
   ```


## 常见应用

1. Java 的IDE（如 idea等）中，编写代码时，自动提示当前对象的方法和字段等。
2. Java 的调试器，能够在调试中获取对象所有字段的值，甚至可以执行其中的任意方法。
3. Spring 中的 IOC 机制。

## 优缺点

优点很明显，给了开发者很大的自由，可以做出很多有意思的事情。缺点也正基于此，性能损耗，不管是本地调用还是动态实现，显然没有直接调用快，另外由于可以使用 AccessibleObject.setAccessible 方法来绕过 Java 语言的访问限制，所以并不安全。

